#!/usr/bin/env python

# Copyright (c) 2007 Johns Hopkins University.
# All rights reserved.
#
# Permission to use, copy, modify, and distribute this software and its
# documentation for any purpose, without fee, and without written
# agreement is hereby granted, provided that the above copyright
# notice, the (updated) modification history and the author appear in
# all copies of this source code.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR CONTRIBUTORS
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, LOSS OF USE, DATA,
# OR PROFITS) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
# THE POSSIBILITY OF SUCH DAMAGE.

# @author Razvan Musaloiu-E. <razvanm@cs.jhu.edu>
# @author Chieh-Jan Mike Liang <cliang4@cs.jhu.edu>

# b6lowpan/nwprog port:
# @author Stephen Dawson-Haggerty <stevedh@cs.berkeley.edu>

import sys, stat, struct, subprocess, time, os.path, socket
try:
    import tos
except ImportError:
    import posix
    sys.path = [os.path.join(posix.environ['TOSROOT'], 'support', 'sdk', 'python')] + sys.path
    import tos
from datetime import datetime

# Path to the python script that builds Deluge image from XML
PATH_PY_BUILD_IMAGE  = os.path.join(os.path.dirname(sys.argv[0]), 'tos-build-deluge-image')

# Commands for NWProg
NWPROG_CMD_ERASE = 1
NWPROG_CMD_WRITE = 2


# Deluge parameters
DELUGE_MAX_PAGES    = 128
DELUGE_IDENT_OFFSET = 0
DELUGE_IDENT_SIZE   = 128

NWPROG_PORT = 5213
NWPROG_PKT_SIZE = 256
NWPROG_REQ_FMT = "!BBH"
NWPROG_REPLY_FMT = "!BBBH"

ERROR_SUCCESS = 0

class CommandFailedException:
    pass

def send_command(cmd_str, retries):
    s.sendto(cmd_str, (remote, NWPROG_PORT))
    s.settimeout(3)
    try:
        data, addr = s.recvfrom(5)
        #make sure this is the guy we're programming
        if (addr[0] == remote):
            (error, cmd, imgno, offset) = struct.unpack(NWPROG_REPLY_FMT, data)
            return (error == ERROR_SUCCESS)
    except socket.timeout:
        # socket timeout out try again
        if retries > 0:
            return send_command(cmd_str, retries - 1)
        else:
            raise CommandFailedException()
def erase(imgNum):
    e_req = struct.pack(NWPROG_REQ_FMT, NWPROG_CMD_ERASE, imgNum, 0)
    return send_command(e_req, 1)

def write(imgNum, data):
    length = len(data)
    total_length = length   # For progress bar
    next_tick = 100         # For progress bar
    start_time = time.time()

    print "[0%        25%         50%         75%         100%]\r[",

    pkt_offset = 0
    pkt_length = 0
    while length > 0:
        if ((length * 100) / total_length) < next_tick:
            next_tick = next_tick - 2
            sys.stdout.write('-')
            sys.stdout.flush()

        # Calculates the payload size for the current packet
        if length >= NWPROG_PKT_SIZE:
            pkt_length = NWPROG_PKT_SIZE
        else:
            pkt_length = length

        sreqpkt = struct.pack(NWPROG_REQ_FMT,
                              NWPROG_CMD_WRITE, imgNum, pkt_offset)

        for i in data[pkt_offset:pkt_offset+pkt_length]:
            sreqpkt += chr(i)

        # Sends packet to serial
        if not send_command(sreqpkt, 3):
            print "\nReceived error from mote while programming"
            print "Perhaps the block size is too large, or the flash is broken?"
            return False

        length -= pkt_length
        pkt_offset += pkt_length


    print '\r' + ' ' * 52,
    elasped_time = time.time() - start_time
    print "\r%s bytes in %.2f seconds (%.4f bytes/s)" % (total_length, elasped_time, int(total_length) / (elasped_time))
    return True


# Injects an image (specified by tos_image_xml) to an image volume
def upload(imgNum, tos_image_xml):
    # Checks for valid file path
    try:
        os.stat(tos_image_xml)         # Checks whether tos_image_xml is a valid file
    except:
        print "ERROR: Unable to find the TOS image XML, \"%s\"" % tos_image_xml
        return False
    try:
        os.stat(PATH_PY_BUILD_IMAGE)   # Checks whether PATH_PY_BUILD_IMAGE is a valid file
    except:
        print "ERROR: Unable to find the image building utility, \"%s\"" % PATH_PY_BUILD_IMAGE
        return False

    # Creates binary image from the TOS image XML
    print "--------------------------------------------------"
    cmd = [PATH_PY_BUILD_IMAGE, "-i", str(imgNum), tos_image_xml]
    print "Create image:", ' '.join(cmd)
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    (out, err) = p.communicate(None)
    print err,
    print "--------------------------------------------------"

    # Writes the new binary image
    image = [struct.unpack("B", c)[0] for c in out]
    if len(image) > 0 and erase(imgNum):
        write(imgNum, image)
    else:
        print "Could not proceed: image size is zero or erase failed"

    return False


def print_usage():
    print "Usage: %s <ipv6_addr> <-e|-u> image_number [options]" % sys.argv[0]
    print "  -u --upload      Upload a compiled TinyOS application"
    print "                   [options]: tos_image.xml file path"
    print "  -e --erase       Erase an image in the external flash"

def checkImgNum():
    global imgNum
    # Checks for valid image number format
    try:
        imgNum = int(sys.argv[3])
    except:
        print "ERROR: Image number is not valid"
        sys.exit(-1)
    return imgNum

# ======== MAIN ======== #
if len(sys.argv) >= 4:

    s = socket.socket(socket.AF_INET6, socket.SOCK_DGRAM)
    remote = sys.argv[1]

    if sys.argv[2] in ["-u", "--upload"] and len(sys.argv) == 5:
        checkImgNum()
        upload(imgNum, sys.argv[4])
    elif sys.argv[2] in ["-e", "--erase"]:
        checkImgNum()
        if erase(imgNum):
            print "Image number %d erased" % imgNum
    else:
        print_usage()
else:
    print_usage()

sys.exit()

