; build - builds the scheme code of a module injection to 
;   statically compile into the SensorScheme runtime

(require   "sensor-net.scm" "modules.scm" "symmap.scm"
           (only (lib "1.ss" "srfi") lset-union lset-difference append-map append-reverse filter-map take drop)
           (only (lib "13.ss" "srfi") string-drop-right string-contains string-reverse)
           (lib "pretty.ss" "mzlib"))
(require (lib "cmdline.ss"))


(define autogen-msg1 "This file is automatically generated by the SensorScheme")
(define autogen-msg2 "build process. Do not edit manually.")
(define c-autogen-msg (format "/* ~a~n * ~a~n */~n" autogen-msg1 autogen-msg2))
(define scheme-autogen-msg (format "; ~a~n; ~a~n~n" autogen-msg1 autogen-msg2))

; first some defines that are in fact configuration values, 
; will become program parameters later.
(define *appdir* #f)

(define (serial-recv line)
  (define (string->byte-list s)
    (if (> (string-length s) 1)
        (cons (string->number (string-take s 2) 16) (string->byte-list (string-drop s 2)))
        '()))
  (printf "received line: ~s~n" line)
  (string->byte-list line))

(define (make-initmessage-h string)
  (define (byte-const byte)
    (string-append "0x" 
                   (let ((s (number->string byte 16)))
                     (if (= (string-length s) 1) (string-append "0" s) s)) 
                   ", "))
  (define (bytes-split byte-list n)
    (if (> (length byte-list) n) 
        (cons (take byte-list n) (bytes-split (drop byte-list n) n))
        (list byte-list)))
  
  (string-append 
   "#ifndef INITMESSAGE_H\n#define INITMESSAGE_H\n\nconst uint16_t initSize = "
   (number->string (length string))
   ";\nconst uint8_t  initMessage[] = {\n"
   (string-drop-right (apply string-append (map (lambda (s) (string-append "        " (apply string-append (map byte-const s)) "\n")) (bytes-split string 8))) 3) "};\n\n#endif\n"))

(define (make-primitives-h symmap prims recvs)
  (define (filter-kind sym)
    (filter-map (lambda (el) (if (eq? (cadr el) sym)
                                 (cons (car el) (cddr el)) #f)) prims))
  (define (c-ident sym)
    (define (esc c) (list #\_ c #\_))
    (list->string (append-map (lambda (c)
                                (case c
                                  [(#\!) (esc #\X)]
                                  [(#\*) (esc #\T)]
                                  [(#\-) (esc #\M)]
                                  [(#\+) (esc #\P)]
                                  [(#\=) (esc #\E)]
                                  [(#\/) (esc #\D)]
                                  [(#\%) (esc #\L)]
                                  [(#\?) (esc #\Q)]
                                  [(#\:) (esc #\C)]
                                  [(#\<) (esc #\S)]
                                  [(#\>) (esc #\G)]
                                  [(#\^) (esc #\W)]
                                  [(#\&) (esc #\N)]
                                  [(#\@) (esc #\A)]
                                  [(#\$) (esc #\O)]
                                  [else (list (char-upcase c))])) (string->list (symbol->string sym)))))
  (define (prim-entry el)
    (format "  _(~a, ~s) /* ~s : ~s */ \\~n" (c-ident (car el)) (cadr el) (car el) (symnum symmap (car el))))
  
  (let ([simple (filter-kind 'simple)]
        [eval (filter-kind 'eval)]
        [appl (filter-kind 'apply)]
        [send (filter-kind 'sender)]
        [recv (map (lambda (el) (list (car el) (cdr el))) recvs)])
    
    (format "~n~n/* builtin primitive functions defined here. */
#define SIMPLE_PRIM_LIST(_) \\~n~a
#define EVAL_PRIM_LIST(_) \\~n~a
#define APPLY_PRIM_LIST(_) \\~n~a
#define SEND_PRIM_LIST(_) \\~n~a
#define RECEIVER_LIST(_) \\~n~a~n" 
            (apply string-append (map prim-entry simple))
            (apply string-append (map prim-entry eval))
            (apply string-append (map prim-entry appl))
            (apply string-append (map prim-entry send))
            (apply string-append (map prim-entry recv)))))


(define (main cmdline)
  (define (filter-defs defs sym)
    (filter-map (lambda (el) 
                  (if (eq? (cadr el) sym)
                      (cons (car el) (cddr el)) #f)) defs))
  (let* ([code-module
          (command-line (car cmdline) (cdr cmdline)
                        (once-each 
                         [("-a" "--appdir") dir "the directory where the TinyOS application is generated" 
                                            (set! *appdir* dir)])
                        (args (filename) ; expects one command-line argument: a filename
                              filename)) ; return a single filename to compile
          ]
         [module-name (string-drop-right 
                       code-module 
                       (+ 1 (string-contains (string-reverse code-module) ".")))])
    (when (not *appdir*)
      (let ([basedir "../../../apps/SensorScheme/"])
        (when (not (directory-exists? basedir))
          (make-directory basedir))
        (set! *appdir* (string-append "../../../apps/SensorScheme/" module-name))
        (when (not (directory-exists? *appdir*))
          (make-directory *appdir*))))
    
    (printf "code-module: ~a~nappdir: ~a~n" 
            code-module *appdir*)
    
    (let*-values ([(symmap) (new-symmap)]
                  [(mdls inits defs) (compile-module code-module)]
                  [(defines) (map (lambda (el) (list (car el) (cdr el))) (filter-defs defs 'define))]
                  [(primitives) (filter-defs defs 'primitive)]
                  [(receivers) (filter-defs defs 'receiver)]
                  [(code) `((%define% ,@(apply append defines)) ,@inits)])
      (printf " defs: ~s~n inits: ~s~n code: ~s~n" defs inits code)
      
      (with-output-to-file (string-append *appdir* "/Primitives.h")
        ; code to compile into binary image
        (lambda () 
          (display c-autogen-msg)
          (display (make-primitives-h symmap primitives receivers))) 'replace)
      
      (with-output-to-file (string-append *appdir* "/InitMessage.h")
        ; code to compile into binary image
        (lambda () 
          (display c-autogen-msg)
          (display (make-initmessage-h (net-encode code symmap)))) 'replace)
      
      (with-output-to-file (string-append *appdir* "/InitMessage.scm")
        ; simulation version
        (lambda () 
          (display scheme-autogen-msg)
          (pretty-print code)) 'replace)

      (with-output-to-file (string-append *appdir* "/config.ncf") 
        ; build message with injector and code
        (lambda () 
          (display scheme-autogen-msg)
          (pretty-print (build-node-conf mdls inits defs symmap))) 'replace)
      
      (with-output-to-file (string-append *appdir* "/"  module-name "C.nc") 
        ; build message with injector and code
        (lambda () 
          (display c-autogen-msg)
          (printf "
#include \"Primitives.h\"
#include \"InitMessage.h\"

configuration ~aC {}

#include \"implementation.h\"
" module-name)) 'replace)
      
            (with-output-to-file (string-append *appdir* "/Makefile") 
        ; build message with injector and code
        (lambda () 
          (printf "COMPONENT=~aC

CFLAGS += -I$(SENSORSCHEME)/tos/lib/SensorScheme \\
          -I$(SENSORSCHEME)/tos/lib/SensorScheme/Interfaces \\
          -I$(SENSORSCHEME)/tos/lib/SensorScheme/Primitives \\
          -I$(TOSDIR)/lib/net \\
          -I$(TOSDIR)/lib/net/le \\
          -I$(TOSDIR)/lib/net/ctp

include $(MAKERULES)
" module-name)) 'replace))))

#;(main (cons (path->string program) (current-command-line-arguments)))
