(module sensor-net mzscheme
  (require 
   (only (lib "13.ss" "srfi") string-take string-drop)
   "symmap.scm")
  
  (provide start-sensor-net net-encode net-decode)
  
  (define cursymmap #f)
  
  (define (start-sensor-net gw-channel symmap simulation?) 
    (printf "start-sensor-net~n")
    (set! cursymmap symmap)
    (let*-values 
        (((in-port out-port) (tcp-connect "localhost" 8763))
         ((my-channel) (make-channel))
         ((in-thread) (thread (lambda ()
                                (let loop ()
                                  (channel-put gw-channel 
                                               (if simulation? (read in-port)
                                                   (net-decode (serial-recv (read-line in-port 'any)) cursymmap)))
                                  (loop))))))
      
      
      (thread (lambda ()                 
                (let wait-loop ()
                  (let ((v (channel-get my-channel)))
                    (unless (equal? v '(quit))                               
                      (if simulation? 
                          (begin (write v out-port) (newline out-port) (flush-output out-port))
                          (serial-send (net-encode v cursymmap) out-port))
                      
                      (wait-loop))
                    (close-input-port in-port)
                    (close-output-port out-port)
                    (kill-thread in-thread)
                    #;(display "end of sensor-net thread\n")))))
      my-channel))
  
  (define TOK_SYM     0)
  (define TOK_NUM     1)
  (define TOK_BROPEN  2)
  (define TOK_BRCLOSE 3)
  
  (define TOK_NIBBLE  TOK_SYM    )
  (define TOK_BYTE    TOK_NUM    )
  (define TOK_WORD    TOK_BROPEN )
  (define TOK_DWORD   TOK_BRCLOSE)
  
  (define (net-decode byte-list symmap) 
    (let ((bitbuf 0)
          (bitcnt 0))
      
      (define (read-bits)
        (when (= bitcnt 0) 
          (set! bitbuf (car byte-list))
          (set! bitcnt 4)
          (set! byte-list (cdr byte-list)))
        (let ((res (modulo bitbuf 4)))
          (set! bitbuf (quotient bitbuf 4))
          (set! bitcnt (- bitcnt 1))
          res))
      
      (define (read-sym)
        (let ((res (symname symmap (let ((n (car byte-list)))
                                     (if (> n (- 256 8)) (- n 256) n)))))
          (set! byte-list (cdr byte-list))
          res))
      
      (define (read-num)
        (let ((bits (read-bits)))
          (cond ((eq? bits TOK_NIBBLE) (+ (* (read-bits) 4) (read-bits)))
                ((eq? bits TOK_BYTE) (let ((res (car byte-list))) (set! byte-list (cdr byte-list)) (if (>= res 128) (- res 256) res)))
                ((eq? bits TOK_WORD) (let ((res (+ (* (cadr byte-list) 256) (car byte-list)))) (set! byte-list (cddr byte-list)) 
                                       (if (>= res (expt 2 15)) (- res (expt 2 16)) res)))
                ((eq? bits TOK_DWORD) (let ((res (+ (* (+ (* (+ (* (cadddr byte-list) 256) (caddr byte-list)) 256) (cadr byte-list)) 256) (car byte-list))))
                                        (set! byte-list (cddddr byte-list)) 
                                        (if (>= res (expt 2 31)) (- res (expt 2 32)) res)))
                (else (display "panic!\n")))))              
      
      (define (read-list)
        (let ((sexpr (read-sexpr)))
          (cond ((eq? sexpr '<brclose>) '())
                ((eq? sexpr '<dot>) (read-sexpr))
                (else (cons sexpr (read-list))))))
      
      (define (read-sexpr)
        (let ((bits (read-bits)))
          (cond ((eq? bits TOK_SYM) (read-sym))
                ((eq? bits TOK_NUM) (read-num))
                ((eq? bits TOK_BROPEN) (read-list))
                ((eq? bits TOK_BRCLOSE) '<brclose>)
                (else (display "panic!\n")))))
      
      (read-sexpr)))
  
  (define (net-encode sexpr symmap)
    (let ((byte-list '())
          (bitbuf 0)
          (bitcnt 0)
          (tls '()))
      
      (define (write-bits tok)
        (when (= bitcnt 4) 
          (set! byte-list (append tls (cons bitbuf byte-list)))
          (set! tls '())
          (set! bitbuf 0)
          (set! bitcnt 0))
        (set! bitbuf (+ (quotient bitbuf 4) (* tok 64)))
        (set! bitcnt (+ bitcnt 1)))
      
      (define (write-sym val)
        (set! tls (cons (modulo (symnum symmap val) 256) tls)))
      
      (define (write-num aval)
        (cond ((<= 0 aval 15) (write-bits TOK_NIBBLE) 
                              (write-bits (quotient aval 4)) (write-bits (modulo aval 4)))
              ((<= (- (/ 256 2)) aval (- (/ 256 2) 1)) 
               (write-bits TOK_BYTE) (set! tls (cons (modulo aval 256) tls)))
              ((<= (- (/ (expt 256 2) 2)) aval (- (/ (expt 256 2) 2) 1)) 
               (write-bits TOK_WORD) 
               (set! tls (cons (quotient (modulo aval (* 256 256)) 256) (cons (modulo aval 256) tls))))
              (else (write-bits TOK_DWORD) 
                    (let ((val (modulo aval (expt 256 4))))
                      (set! tls 
                            (cons (modulo (quotient val (expt 256 3)) 256) 
                                  (cons (modulo (quotient val (* 256 256)) 256) 
                                        (cons (modulo (quotient val 256) 256) 
                                              (cons (modulo val 256) tls)))))))))
      (define (write-list sexpr)
        (cond ((pair? sexpr) (write-sexpr (car sexpr)) (write-list (cdr sexpr)))
              ((null? sexpr) (write-bits TOK_BRCLOSE))
              (else (write-bits TOK_SYM) (write-sym '<dot>) (write-sexpr sexpr))))
      
      (define (write-sexpr sexpr)
        (cond ((or (symbol? sexpr) (boolean? sexpr)) (write-bits TOK_SYM) (write-sym sexpr))
              ((number? sexpr) (write-bits TOK_NUM) (write-num sexpr))
              ((pair? sexpr) (write-bits TOK_BROPEN) (write-list sexpr))
              ((string? sexpr) (display "found a string in code") (newline))
              ((null? sexpr) (write-bits TOK_BROPEN) (write-bits TOK_BRCLOSE))))
      
      (define (flush)
        (define (do-flush)
          (write-bits TOK_BRCLOSE)
          (unless (= bitcnt 1)
            (do-flush)))
        (if (= bitcnt 4)
            (begin (do-flush) #;(set! byte-list (cdr byte-list)))
            (do-flush)))
      
      (write-sexpr sexpr)
      (flush)
      (reverse byte-list)))
  
  (define (serial-recv line)
    (define (string->byte-list s)
      (if (> (string-length s) 1)
          (cons (string->number (string-take s 2) 16) (string->byte-list (string-drop s 2)))
          '()))
    (string->byte-list line))
  
  
  (define (serial-send string out-port) 
    (let ((res (apply string-append 
                      (map (lambda (x) (let ((s (number->string x 16)))
                                         (if (= (string-length s) 1) (string-append "0" s) s))) 
                           string))))
      #;(printf "serial-send ~a -> ~a~n" string res)
      (display res out-port) (newline out-port) (flush-output out-port)))
  )