#!/usr/bin/env mzscheme -u
; build - builds the scheme code of a module injection to 
;   statically compile into the SensorScheme runtime

#lang scheme

(require (file "sensor-net.scm") (file "modules.scm") (file "symmap.scm")
         (only-in srfi/1 lset-union lset-difference append-map append-reverse filter-map take drop)
         (only-in srfi/13 string-drop-right string-contains string-reverse)
         scheme/pretty)

(provide main)

(define autogen-msg1 "This file is automatically generated by the SensorScheme")
(define autogen-msg2 "build process. Do not edit manually.")
(define c-autogen-msg (format "/* ~a~n * ~a~n */~n" autogen-msg1 autogen-msg2))
(define scheme-autogen-msg (format "; ~a~n; ~a~n~n" autogen-msg1 autogen-msg2))

; vaiables tht hold the command line parameter switches.
(define *appdir* #f)
; and the setter function
(define (set-appdir! v) (set! *appdir* v))
; vaiables tht hold the command line parameter switches.
(define *verbose* #f)
; and the setter function
(define (set-verbose! v) (set! *verbose* v))

(define (make-initmessage-h string)
  (define (byte-const byte)
    (string-append "0x" 
                   (let ((s (number->string byte 16)))
                     (if (= (string-length s) 1) (string-append "0" s) s)) 
                   ", "))
  (define (bytes-split byte-list n)
    (if (> (length byte-list) n) 
        (cons (take byte-list n) (bytes-split (drop byte-list n) n))
        (list byte-list)))
  
  (string-append 
   "#ifndef INITMESSAGE_H\n#define INITMESSAGE_H\n\nconst uint16_t initSize = "
   (number->string (length string))
   ";\nconst uint8_t  initMessage[] = {\n"
   (string-drop-right (apply string-append (map (lambda (s) (string-append "        " (apply string-append (map byte-const s)) "\n")) 
                                                (bytes-split string 8))) 3) "};\n\n#endif\n"))

; generates the contents of the primitives.h file from deduced primitives 
; and updates symbols file if needed
(define (make-primitives-h prims recvs)
  (let ([symmap (read-symmap-file *appdir*)])
  (define (filter-kind sym)
    (filter-map (lambda (el) (if (eq? (caadr el) sym)
                                 (cons (car el) (cdadr el)) #f)) prims))
  
  (define (prim-entry el)
    (format "  _(~a, ~s) /* ~s : ~s */ \\~n" (c-ident (car el)) (cadr el) (car el) (symnum symmap (car el))))
  
  (let-values ([(simple eval appl send) (apply values (map (lambda (x) (filter-kind x)) '(simple eval appl send)))])
    
    (begin0 
      (format "~n~n/* builtin primitive functions defined here. */
#define SIMPLE_PRIM_LIST(_) \\~n~a
#define EVAL_PRIM_LIST(_) \\~n~a
#define APPLY_PRIM_LIST(_) \\~n~a
#define SEND_PRIM_LIST(_) \\~n~a
#define RECEIVER_LIST(_) \\~n~a~n" 
            (apply string-append (map prim-entry simple))
            (apply string-append (map prim-entry eval))
            (apply string-append (map prim-entry appl))
            (apply string-append (map prim-entry send))
            (apply string-append (map prim-entry recvs)))
      (write-symmap-file symmap *appdir*)))))


(define (main cmdline)
  (define (filter-defs defs sym)
    (filter-map (lambda (el) 
                  (if (eq? (cadr el) sym)
                      (cons (car el) (cddr el)) #f)) defs))
  
  (let*-values 
      ([(code-module)
        (command-line #:argv cmdline
                      #:once-each 
                      [("-a" "--appdir") dir "the directory where the TinyOS application is generated" 
                                         (set-appdir! (string->path dir))]
                      [("-m" "--macroexand") "print macro-expansion information" 
                                             (set-module-macroexpand! #t)]
                      [("-v" "--verbose") "be verbose" 
                                          (set-module-verbose! #t)
                                          (set-verbose! #t)]
                      #:args (filename) ; expects one command-line argument: a filename
                      (unless (file-exists? filename) (raise-user-error 'build "~s does not exist" filename)) 
                      filename) ; return a single filename to compile
        ]
       [(base name must-be-dir?) (split-path (path->complete-path (string->path code-module)))]
       [(module-name) (string-drop-right (path->string name) 
                                         (+ 1 (string-contains (string-reverse code-module) ".")))])
    (when (not *appdir*) (set! *appdir* (build-path base module-name)))
    (when (not (directory-exists? *appdir*))
      (make-directory *appdir*))
    
    (printf "Generating NesC application for module ~s ...~n" code-module)
    (printf "Target directory is ~a~n" *appdir*)
    
    (let*-values ([(mdls defs inits) (compile-module code-module)]
                  [(defines consts primitives receivers) 
                   (apply values (map (lambda (x) (filter-defs defs x)) '(define const primitive receiver)))]                  
                  [(code) `((%define% ,@(apply append defines) ,@(apply append consts)) ,@inits)])
      (when *verbose* (printf " defs: ~s~n~n  consts ~s~n~n inits: ~s~n~n code: ~s~n~n" defs consts inits code))
      
      (with-output-to-file (build-path *appdir* "Primitives.h")
        ; code to compile into binary image
        (lambda () 
          (display c-autogen-msg)
          (display (make-primitives-h primitives receivers))) #:exists 'replace)
      
      (let ([bytes (net-encode-mapfile code *appdir*)])
        (printf "Module ~s compiled to size of ~a bytes ~n" code-module (length bytes))
        (with-output-to-file (build-path *appdir* "InitMessage.h")
          ; init message
          (lambda () 
            (display c-autogen-msg)
            (display (make-initmessage-h bytes))) #:exists 'replace))
      
      (with-output-to-file (build-path *appdir* "InitMessage.scm")
        ; simulation version
        (lambda () 
          (display scheme-autogen-msg)
          (pretty-print code)) #:exists 'replace)
      
      (with-output-to-file (build-path *appdir* "config.ncf") 
        ; save the compiled code
        (lambda () 
          (display scheme-autogen-msg)
          (write-node-conf mdls defs inits)) #:exists 'replace)
      
      (with-output-to-file (build-path *appdir* (string-append module-name "C.nc")) 
        ; build message with injector and code
        (lambda () 
          (display c-autogen-msg)
          (printf "
#include \"Primitives.h\"
#include \"InitMessage.h\"
#include \"printfdebug.h\"

configuration ~aC {}

#include \"implementation.h\"
" module-name)) #:exists 'replace)
      
      (if (file-exists? (build-path *appdir* "Makefile"))
          (printf "Makefile already exists, not overwriting.~n")
          (begin
            (printf "Generating Makefile ...~n")
            (with-output-to-file (build-path *appdir* "Makefile") 
              ; build message with injector and code
              (lambda () 
                (printf "COMPONENT=~aC

CFLAGS += -I$(TOSDIR)/lib/SensorScheme \\
          -I$(TOSDIR)/lib/SensorScheme/Interfaces \\
          -I$(TOSDIR)/lib/SensorScheme/Primitives \\
          -I$(TOSDIR)/lib/printf \\
          -I$(TOSDIR)/lib/net \\
          -I$(TOSDIR)/lib/net/le \\
          -I$(TOSDIR)/lib/net/ctp

CFLAGS += -DPRINTF_DBG=\"\\\"SensorSchemePrint\"\\\"

include $(MAKERULES)
" module-name)) #:exists 'replace)))
      
      (if (file-exists? (build-path *appdir* "sim.py"))
          (printf "Simulation script already exists, not overwriting.~n")
          (begin
            (printf "Generating sim.py ...~n")
            (copy-file (build-path (getenv "TOSROOT") "support" "sdk" "pltscheme" "sim.py") (build-path *appdir* "sim.py")))))))

(main (current-command-line-arguments))