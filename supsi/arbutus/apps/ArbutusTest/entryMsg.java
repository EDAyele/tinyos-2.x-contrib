/**
 * This class is automatically generated by mig. DO NOT EDIT THIS FILE.
 * This class implements a Java interface to the 'entryMsg'
 * message type.
 */

public class entryMsg extends net.tinyos.message.Message {

    /** The default size of this message type in bytes. */
    public static final int DEFAULT_MESSAGE_SIZE = 27;

    /** The Active Message type associated with this message. */
    public static final int AM_TYPE = 56;

    /** Create a new entryMsg of size 27. */
    public entryMsg() {
        super(DEFAULT_MESSAGE_SIZE);
        amTypeSet(AM_TYPE);
    }

    /** Create a new entryMsg of the given data_length. */
    public entryMsg(int data_length) {
        super(data_length);
        amTypeSet(AM_TYPE);
    }

    /**
     * Create a new entryMsg with the given data_length
     * and base offset.
     */
    public entryMsg(int data_length, int base_offset) {
        super(data_length, base_offset);
        amTypeSet(AM_TYPE);
    }

    /**
     * Create a new entryMsg using the given byte array
     * as backing store.
     */
    public entryMsg(byte[] data) {
        super(data);
        amTypeSet(AM_TYPE);
    }

    /**
     * Create a new entryMsg using the given byte array
     * as backing store, with the given base offset.
     */
    public entryMsg(byte[] data, int base_offset) {
        super(data, base_offset);
        amTypeSet(AM_TYPE);
    }

    /**
     * Create a new entryMsg using the given byte array
     * as backing store, with the given base offset and data length.
     */
    public entryMsg(byte[] data, int base_offset, int data_length) {
        super(data, base_offset, data_length);
        amTypeSet(AM_TYPE);
    }

    /**
     * Create a new entryMsg embedded in the given message
     * at the given base offset.
     */
    public entryMsg(net.tinyos.message.Message msg, int base_offset) {
        super(msg, base_offset, DEFAULT_MESSAGE_SIZE);
        amTypeSet(AM_TYPE);
    }

    /**
     * Create a new entryMsg embedded in the given message
     * at the given base offset and length.
     */
    public entryMsg(net.tinyos.message.Message msg, int base_offset, int data_length) {
        super(msg, base_offset, data_length);
        amTypeSet(AM_TYPE);
    }

    /**
    /* Return a String representation of this message. Includes the
     * message type name and the non-indexed field values.
     */
    public String toString() {
      String s = "Message <entryMsg> \n";
      try {
        s += "  [node=0x"+Long.toHexString(get_node())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [local_hopcount=0x"+Long.toHexString(get_local_hopcount())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [local_adjustedHopcount=0x"+Long.toHexString(get_local_adjustedHopcount())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [ll_addr=0x"+Long.toHexString(get_ll_addr())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [isParent=0x"+Long.toHexString(get_isParent())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [preferredParent=0x"+Long.toHexString(get_preferredParent())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [formerParent=0x"+Long.toHexString(get_formerParent())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [beaconerParent=0x"+Long.toHexString(get_beaconerParent())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [beaconer_hopcount=0x"+Long.toHexString(get_beaconer_hopcount())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [lastseq=0x"+Long.toHexString(get_lastseq())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [flags=0x"+Long.toHexString(get_flags())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [rss=0x"+Long.toHexString(get_rss())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [lqi=0x"+Long.toHexString(get_lqi())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [rssBottleneck=0x"+Long.toHexString(get_rssBottleneck())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [lqiBottleneck=0x"+Long.toHexString(get_lqiBottleneck())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [rnp=0x"+Long.toHexString(get_rnp())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [freaky=0x"+Long.toHexString(get_freaky())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [metric=0x"+Long.toHexString(get_metric())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [tableIndex=0x"+Long.toHexString(get_tableIndex())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      try {
        s += "  [controlState=0x"+Long.toHexString(get_controlState())+"]\n";
      } catch (ArrayIndexOutOfBoundsException aioobe) { /* Skip field */ }
      return s;
    }

    // Message-type-specific access methods appear below.

    /////////////////////////////////////////////////////////
    // Accessor methods for field: node
    //   Field type: int, unsigned
    //   Offset (bits): 0
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'node' is signed (false).
     */
    public static boolean isSigned_node() {
        return false;
    }

    /**
     * Return whether the field 'node' is an array (false).
     */
    public static boolean isArray_node() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'node'
     */
    public static int offset_node() {
        return (0 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'node'
     */
    public static int offsetBits_node() {
        return 0;
    }

    /**
     * Return the value (as a int) of the field 'node'
     */
    public int get_node() {
        return (int)getUIntBEElement(offsetBits_node(), 16);
    }

    /**
     * Set the value of the field 'node'
     */
    public void set_node(int value) {
        setUIntBEElement(offsetBits_node(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'node'
     */
    public static int size_node() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'node'
     */
    public static int sizeBits_node() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: local_hopcount
    //   Field type: short, unsigned
    //   Offset (bits): 16
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'local_hopcount' is signed (false).
     */
    public static boolean isSigned_local_hopcount() {
        return false;
    }

    /**
     * Return whether the field 'local_hopcount' is an array (false).
     */
    public static boolean isArray_local_hopcount() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'local_hopcount'
     */
    public static int offset_local_hopcount() {
        return (16 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'local_hopcount'
     */
    public static int offsetBits_local_hopcount() {
        return 16;
    }

    /**
     * Return the value (as a short) of the field 'local_hopcount'
     */
    public short get_local_hopcount() {
        return (short)getUIntBEElement(offsetBits_local_hopcount(), 8);
    }

    /**
     * Set the value of the field 'local_hopcount'
     */
    public void set_local_hopcount(short value) {
        setUIntBEElement(offsetBits_local_hopcount(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'local_hopcount'
     */
    public static int size_local_hopcount() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'local_hopcount'
     */
    public static int sizeBits_local_hopcount() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: local_adjustedHopcount
    //   Field type: short, unsigned
    //   Offset (bits): 24
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'local_adjustedHopcount' is signed (false).
     */
    public static boolean isSigned_local_adjustedHopcount() {
        return false;
    }

    /**
     * Return whether the field 'local_adjustedHopcount' is an array (false).
     */
    public static boolean isArray_local_adjustedHopcount() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'local_adjustedHopcount'
     */
    public static int offset_local_adjustedHopcount() {
        return (24 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'local_adjustedHopcount'
     */
    public static int offsetBits_local_adjustedHopcount() {
        return 24;
    }

    /**
     * Return the value (as a short) of the field 'local_adjustedHopcount'
     */
    public short get_local_adjustedHopcount() {
        return (short)getUIntBEElement(offsetBits_local_adjustedHopcount(), 8);
    }

    /**
     * Set the value of the field 'local_adjustedHopcount'
     */
    public void set_local_adjustedHopcount(short value) {
        setUIntBEElement(offsetBits_local_adjustedHopcount(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'local_adjustedHopcount'
     */
    public static int size_local_adjustedHopcount() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'local_adjustedHopcount'
     */
    public static int sizeBits_local_adjustedHopcount() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: ll_addr
    //   Field type: int, unsigned
    //   Offset (bits): 32
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'll_addr' is signed (false).
     */
    public static boolean isSigned_ll_addr() {
        return false;
    }

    /**
     * Return whether the field 'll_addr' is an array (false).
     */
    public static boolean isArray_ll_addr() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'll_addr'
     */
    public static int offset_ll_addr() {
        return (32 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'll_addr'
     */
    public static int offsetBits_ll_addr() {
        return 32;
    }

    /**
     * Return the value (as a int) of the field 'll_addr'
     */
    public int get_ll_addr() {
        return (int)getUIntBEElement(offsetBits_ll_addr(), 16);
    }

    /**
     * Set the value of the field 'll_addr'
     */
    public void set_ll_addr(int value) {
        setUIntBEElement(offsetBits_ll_addr(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'll_addr'
     */
    public static int size_ll_addr() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'll_addr'
     */
    public static int sizeBits_ll_addr() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: isParent
    //   Field type: int, unsigned
    //   Offset (bits): 48
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'isParent' is signed (false).
     */
    public static boolean isSigned_isParent() {
        return false;
    }

    /**
     * Return whether the field 'isParent' is an array (false).
     */
    public static boolean isArray_isParent() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'isParent'
     */
    public static int offset_isParent() {
        return (48 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'isParent'
     */
    public static int offsetBits_isParent() {
        return 48;
    }

    /**
     * Return the value (as a int) of the field 'isParent'
     */
    public int get_isParent() {
        return (int)getUIntBEElement(offsetBits_isParent(), 16);
    }

    /**
     * Set the value of the field 'isParent'
     */
    public void set_isParent(int value) {
        setUIntBEElement(offsetBits_isParent(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'isParent'
     */
    public static int size_isParent() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'isParent'
     */
    public static int sizeBits_isParent() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: preferredParent
    //   Field type: short, unsigned
    //   Offset (bits): 64
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'preferredParent' is signed (false).
     */
    public static boolean isSigned_preferredParent() {
        return false;
    }

    /**
     * Return whether the field 'preferredParent' is an array (false).
     */
    public static boolean isArray_preferredParent() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'preferredParent'
     */
    public static int offset_preferredParent() {
        return (64 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'preferredParent'
     */
    public static int offsetBits_preferredParent() {
        return 64;
    }

    /**
     * Return the value (as a short) of the field 'preferredParent'
     */
    public short get_preferredParent() {
        return (short)getUIntBEElement(offsetBits_preferredParent(), 8);
    }

    /**
     * Set the value of the field 'preferredParent'
     */
    public void set_preferredParent(short value) {
        setUIntBEElement(offsetBits_preferredParent(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'preferredParent'
     */
    public static int size_preferredParent() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'preferredParent'
     */
    public static int sizeBits_preferredParent() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: formerParent
    //   Field type: int, unsigned
    //   Offset (bits): 72
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'formerParent' is signed (false).
     */
    public static boolean isSigned_formerParent() {
        return false;
    }

    /**
     * Return whether the field 'formerParent' is an array (false).
     */
    public static boolean isArray_formerParent() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'formerParent'
     */
    public static int offset_formerParent() {
        return (72 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'formerParent'
     */
    public static int offsetBits_formerParent() {
        return 72;
    }

    /**
     * Return the value (as a int) of the field 'formerParent'
     */
    public int get_formerParent() {
        return (int)getUIntBEElement(offsetBits_formerParent(), 16);
    }

    /**
     * Set the value of the field 'formerParent'
     */
    public void set_formerParent(int value) {
        setUIntBEElement(offsetBits_formerParent(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'formerParent'
     */
    public static int size_formerParent() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'formerParent'
     */
    public static int sizeBits_formerParent() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: beaconerParent
    //   Field type: int, unsigned
    //   Offset (bits): 88
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'beaconerParent' is signed (false).
     */
    public static boolean isSigned_beaconerParent() {
        return false;
    }

    /**
     * Return whether the field 'beaconerParent' is an array (false).
     */
    public static boolean isArray_beaconerParent() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'beaconerParent'
     */
    public static int offset_beaconerParent() {
        return (88 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'beaconerParent'
     */
    public static int offsetBits_beaconerParent() {
        return 88;
    }

    /**
     * Return the value (as a int) of the field 'beaconerParent'
     */
    public int get_beaconerParent() {
        return (int)getUIntBEElement(offsetBits_beaconerParent(), 16);
    }

    /**
     * Set the value of the field 'beaconerParent'
     */
    public void set_beaconerParent(int value) {
        setUIntBEElement(offsetBits_beaconerParent(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'beaconerParent'
     */
    public static int size_beaconerParent() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'beaconerParent'
     */
    public static int sizeBits_beaconerParent() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: beaconer_hopcount
    //   Field type: short, unsigned
    //   Offset (bits): 104
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'beaconer_hopcount' is signed (false).
     */
    public static boolean isSigned_beaconer_hopcount() {
        return false;
    }

    /**
     * Return whether the field 'beaconer_hopcount' is an array (false).
     */
    public static boolean isArray_beaconer_hopcount() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'beaconer_hopcount'
     */
    public static int offset_beaconer_hopcount() {
        return (104 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'beaconer_hopcount'
     */
    public static int offsetBits_beaconer_hopcount() {
        return 104;
    }

    /**
     * Return the value (as a short) of the field 'beaconer_hopcount'
     */
    public short get_beaconer_hopcount() {
        return (short)getUIntBEElement(offsetBits_beaconer_hopcount(), 8);
    }

    /**
     * Set the value of the field 'beaconer_hopcount'
     */
    public void set_beaconer_hopcount(short value) {
        setUIntBEElement(offsetBits_beaconer_hopcount(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'beaconer_hopcount'
     */
    public static int size_beaconer_hopcount() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'beaconer_hopcount'
     */
    public static int sizeBits_beaconer_hopcount() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: lastseq
    //   Field type: short, unsigned
    //   Offset (bits): 112
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'lastseq' is signed (false).
     */
    public static boolean isSigned_lastseq() {
        return false;
    }

    /**
     * Return whether the field 'lastseq' is an array (false).
     */
    public static boolean isArray_lastseq() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'lastseq'
     */
    public static int offset_lastseq() {
        return (112 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'lastseq'
     */
    public static int offsetBits_lastseq() {
        return 112;
    }

    /**
     * Return the value (as a short) of the field 'lastseq'
     */
    public short get_lastseq() {
        return (short)getUIntBEElement(offsetBits_lastseq(), 8);
    }

    /**
     * Set the value of the field 'lastseq'
     */
    public void set_lastseq(short value) {
        setUIntBEElement(offsetBits_lastseq(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'lastseq'
     */
    public static int size_lastseq() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'lastseq'
     */
    public static int sizeBits_lastseq() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: flags
    //   Field type: short, unsigned
    //   Offset (bits): 120
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'flags' is signed (false).
     */
    public static boolean isSigned_flags() {
        return false;
    }

    /**
     * Return whether the field 'flags' is an array (false).
     */
    public static boolean isArray_flags() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'flags'
     */
    public static int offset_flags() {
        return (120 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'flags'
     */
    public static int offsetBits_flags() {
        return 120;
    }

    /**
     * Return the value (as a short) of the field 'flags'
     */
    public short get_flags() {
        return (short)getUIntBEElement(offsetBits_flags(), 8);
    }

    /**
     * Set the value of the field 'flags'
     */
    public void set_flags(short value) {
        setUIntBEElement(offsetBits_flags(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'flags'
     */
    public static int size_flags() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'flags'
     */
    public static int sizeBits_flags() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: rss
    //   Field type: short, unsigned
    //   Offset (bits): 128
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'rss' is signed (false).
     */
    public static boolean isSigned_rss() {
        return false;
    }

    /**
     * Return whether the field 'rss' is an array (false).
     */
    public static boolean isArray_rss() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'rss'
     */
    public static int offset_rss() {
        return (128 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'rss'
     */
    public static int offsetBits_rss() {
        return 128;
    }

    /**
     * Return the value (as a short) of the field 'rss'
     */
    public short get_rss() {
        return (short)getUIntBEElement(offsetBits_rss(), 8);
    }

    /**
     * Set the value of the field 'rss'
     */
    public void set_rss(short value) {
        setUIntBEElement(offsetBits_rss(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'rss'
     */
    public static int size_rss() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'rss'
     */
    public static int sizeBits_rss() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: lqi
    //   Field type: short, unsigned
    //   Offset (bits): 136
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'lqi' is signed (false).
     */
    public static boolean isSigned_lqi() {
        return false;
    }

    /**
     * Return whether the field 'lqi' is an array (false).
     */
    public static boolean isArray_lqi() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'lqi'
     */
    public static int offset_lqi() {
        return (136 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'lqi'
     */
    public static int offsetBits_lqi() {
        return 136;
    }

    /**
     * Return the value (as a short) of the field 'lqi'
     */
    public short get_lqi() {
        return (short)getUIntBEElement(offsetBits_lqi(), 8);
    }

    /**
     * Set the value of the field 'lqi'
     */
    public void set_lqi(short value) {
        setUIntBEElement(offsetBits_lqi(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'lqi'
     */
    public static int size_lqi() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'lqi'
     */
    public static int sizeBits_lqi() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: rssBottleneck
    //   Field type: short, unsigned
    //   Offset (bits): 144
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'rssBottleneck' is signed (false).
     */
    public static boolean isSigned_rssBottleneck() {
        return false;
    }

    /**
     * Return whether the field 'rssBottleneck' is an array (false).
     */
    public static boolean isArray_rssBottleneck() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'rssBottleneck'
     */
    public static int offset_rssBottleneck() {
        return (144 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'rssBottleneck'
     */
    public static int offsetBits_rssBottleneck() {
        return 144;
    }

    /**
     * Return the value (as a short) of the field 'rssBottleneck'
     */
    public short get_rssBottleneck() {
        return (short)getUIntBEElement(offsetBits_rssBottleneck(), 8);
    }

    /**
     * Set the value of the field 'rssBottleneck'
     */
    public void set_rssBottleneck(short value) {
        setUIntBEElement(offsetBits_rssBottleneck(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'rssBottleneck'
     */
    public static int size_rssBottleneck() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'rssBottleneck'
     */
    public static int sizeBits_rssBottleneck() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: lqiBottleneck
    //   Field type: short, unsigned
    //   Offset (bits): 152
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'lqiBottleneck' is signed (false).
     */
    public static boolean isSigned_lqiBottleneck() {
        return false;
    }

    /**
     * Return whether the field 'lqiBottleneck' is an array (false).
     */
    public static boolean isArray_lqiBottleneck() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'lqiBottleneck'
     */
    public static int offset_lqiBottleneck() {
        return (152 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'lqiBottleneck'
     */
    public static int offsetBits_lqiBottleneck() {
        return 152;
    }

    /**
     * Return the value (as a short) of the field 'lqiBottleneck'
     */
    public short get_lqiBottleneck() {
        return (short)getUIntBEElement(offsetBits_lqiBottleneck(), 8);
    }

    /**
     * Set the value of the field 'lqiBottleneck'
     */
    public void set_lqiBottleneck(short value) {
        setUIntBEElement(offsetBits_lqiBottleneck(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'lqiBottleneck'
     */
    public static int size_lqiBottleneck() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'lqiBottleneck'
     */
    public static int sizeBits_lqiBottleneck() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: rnp
    //   Field type: int, unsigned
    //   Offset (bits): 160
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'rnp' is signed (false).
     */
    public static boolean isSigned_rnp() {
        return false;
    }

    /**
     * Return whether the field 'rnp' is an array (false).
     */
    public static boolean isArray_rnp() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'rnp'
     */
    public static int offset_rnp() {
        return (160 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'rnp'
     */
    public static int offsetBits_rnp() {
        return 160;
    }

    /**
     * Return the value (as a int) of the field 'rnp'
     */
    public int get_rnp() {
        return (int)getUIntBEElement(offsetBits_rnp(), 16);
    }

    /**
     * Set the value of the field 'rnp'
     */
    public void set_rnp(int value) {
        setUIntBEElement(offsetBits_rnp(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'rnp'
     */
    public static int size_rnp() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'rnp'
     */
    public static int sizeBits_rnp() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: freaky
    //   Field type: short, unsigned
    //   Offset (bits): 176
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'freaky' is signed (false).
     */
    public static boolean isSigned_freaky() {
        return false;
    }

    /**
     * Return whether the field 'freaky' is an array (false).
     */
    public static boolean isArray_freaky() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'freaky'
     */
    public static int offset_freaky() {
        return (176 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'freaky'
     */
    public static int offsetBits_freaky() {
        return 176;
    }

    /**
     * Return the value (as a short) of the field 'freaky'
     */
    public short get_freaky() {
        return (short)getUIntBEElement(offsetBits_freaky(), 8);
    }

    /**
     * Set the value of the field 'freaky'
     */
    public void set_freaky(short value) {
        setUIntBEElement(offsetBits_freaky(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'freaky'
     */
    public static int size_freaky() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'freaky'
     */
    public static int sizeBits_freaky() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: metric
    //   Field type: int, unsigned
    //   Offset (bits): 184
    //   Size (bits): 16
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'metric' is signed (false).
     */
    public static boolean isSigned_metric() {
        return false;
    }

    /**
     * Return whether the field 'metric' is an array (false).
     */
    public static boolean isArray_metric() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'metric'
     */
    public static int offset_metric() {
        return (184 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'metric'
     */
    public static int offsetBits_metric() {
        return 184;
    }

    /**
     * Return the value (as a int) of the field 'metric'
     */
    public int get_metric() {
        return (int)getUIntBEElement(offsetBits_metric(), 16);
    }

    /**
     * Set the value of the field 'metric'
     */
    public void set_metric(int value) {
        setUIntBEElement(offsetBits_metric(), 16, value);
    }

    /**
     * Return the size, in bytes, of the field 'metric'
     */
    public static int size_metric() {
        return (16 / 8);
    }

    /**
     * Return the size, in bits, of the field 'metric'
     */
    public static int sizeBits_metric() {
        return 16;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: tableIndex
    //   Field type: short, unsigned
    //   Offset (bits): 200
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'tableIndex' is signed (false).
     */
    public static boolean isSigned_tableIndex() {
        return false;
    }

    /**
     * Return whether the field 'tableIndex' is an array (false).
     */
    public static boolean isArray_tableIndex() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'tableIndex'
     */
    public static int offset_tableIndex() {
        return (200 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'tableIndex'
     */
    public static int offsetBits_tableIndex() {
        return 200;
    }

    /**
     * Return the value (as a short) of the field 'tableIndex'
     */
    public short get_tableIndex() {
        return (short)getUIntBEElement(offsetBits_tableIndex(), 8);
    }

    /**
     * Set the value of the field 'tableIndex'
     */
    public void set_tableIndex(short value) {
        setUIntBEElement(offsetBits_tableIndex(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'tableIndex'
     */
    public static int size_tableIndex() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'tableIndex'
     */
    public static int sizeBits_tableIndex() {
        return 8;
    }

    /////////////////////////////////////////////////////////
    // Accessor methods for field: controlState
    //   Field type: short, unsigned
    //   Offset (bits): 208
    //   Size (bits): 8
    /////////////////////////////////////////////////////////

    /**
     * Return whether the field 'controlState' is signed (false).
     */
    public static boolean isSigned_controlState() {
        return false;
    }

    /**
     * Return whether the field 'controlState' is an array (false).
     */
    public static boolean isArray_controlState() {
        return false;
    }

    /**
     * Return the offset (in bytes) of the field 'controlState'
     */
    public static int offset_controlState() {
        return (208 / 8);
    }

    /**
     * Return the offset (in bits) of the field 'controlState'
     */
    public static int offsetBits_controlState() {
        return 208;
    }

    /**
     * Return the value (as a short) of the field 'controlState'
     */
    public short get_controlState() {
        return (short)getUIntBEElement(offsetBits_controlState(), 8);
    }

    /**
     * Set the value of the field 'controlState'
     */
    public void set_controlState(short value) {
        setUIntBEElement(offsetBits_controlState(), 8, value);
    }

    /**
     * Return the size, in bytes, of the field 'controlState'
     */
    public static int size_controlState() {
        return (8 / 8);
    }

    /**
     * Return the size, in bits, of the field 'controlState'
     */
    public static int sizeBits_controlState() {
        return 8;
    }

}
